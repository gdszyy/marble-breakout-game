# 弹珠编程打砖块游戏 - 完整伪代码文档

## 目录

1. [游戏概述](#游戏概述)
2. [核心设计理念](#核心设计理念)
3. [技术架构](#技术架构)
4. [实现流程](#实现流程)
5. [详细伪代码](#详细伪代码)
6. [配置参数](#配置参数)
7. [扩展建议](#扩展建议)

---

## 游戏概述

**弹珠编程打砖块 - 炼金术士守城**是一款结合了打砖块、子弹编程和Roguelike元素的创新游戏。玩家扮演炼金术士，通过收集魔药材料、配制魔药配方、发射魔药来抵御不断逼近的晶石魔像。

### 核心玩法循环

```
1. 砖块生成阶段 → 新的晶石魔像出现
2. 子弹装填阶段 → 弹珠掉落，收集材料，配制魔药
3. 玩家行动阶段 → 发射魔药攻击魔像
4. 砖块行动阶段 → 魔像逼近，触及底部则扣血
5. 返回步骤1
```

### 游戏特色

- **子弹编程系统**: 玩家通过组合不同的魔药模块来创造独特的攻击效果
- **缓冲阵列机制**: 弹珠在掉落过程中碰撞缓冲器收集材料
- **能量管理**: 收集的材料转化为能量，支持多次发射
- **奖励缓冲器**: 触发转盘抽奖获得稀有材料
- **回合制节奏**: 通过事件管理器实现流畅的回合制体验

---

## 核心设计理念

### 1. 事件驱动架构

游戏不使用传统的"回合"概念，而是通过**事件管理器**切换不同的游戏阶段：

```
事件管理器
├── BRICK_SPAWN (砖块生成)
├── BULLET_LOADING (子弹装填)
├── PLAYER_ACTION (玩家行动)
├── BRICK_ACTION (砖块行动)
└── GAME_OVER (游戏结束)
```

每个事件阶段有独立的逻辑和UI表现，通过事件切换实现流畅的游戏节奏。

### 2. 子弹编程系统

玩家通过组合**基础子弹**和**修饰模块**来创造独特的攻击效果：

**基础子弹**（必须有一个）:
- 普通子弹: 基础攻击，碰撞后反弹或消失
- 穿透子弹: 穿透敌人持续造成伤害
- AOE子弹: 碰撞时产生范围伤害圆环

**修饰模块**（可选，必须在基础子弹左侧）:
- 反弹+1: 增加一次反弹次数
- 散射+1: 发射时分裂成多个
- 齐射+1: 同时发射多个
- 碰撞触发: 碰撞时触发额外效果

**编程规则**:
1. 至少包含一个基础子弹
2. 修饰模块必须在基础子弹左侧
3. 模块数量越多，能量消耗越大

### 3. 能量系统

```
能量获取:
- 弹珠收集材料 → 转化为能量
- 空槽充能: 100%效率
- 满槽充能: 80%效率

能量消耗:
- 每个模块消耗10能量
- 发射时消耗 = 模块数量 × 10

可发射次数 = 当前能量 ÷ 单次消耗
```

### 4. 缓冲阵列系统

弹珠从顶部掉落，碰撞缓冲器收集材料：

```
缓冲器特性:
- 碰撞后进入冷却（500ms）
- 每次碰撞弹珠速度衰减
- 碰撞次数越多，速度越慢

奖励缓冲器:
- 固定位置，金色闪烁
- 触发转盘抽奖
- 从收集的材料中随机抽取一个
```

---

## 技术架构

### 系统模块划分

```
游戏系统
├── 核心引擎层
│   ├── GameEngine (游戏引擎)
│   ├── EventManager (事件管理器)
│   └── GameStateFactory (状态工厂)
├── 逻辑层
│   ├── BulletModuleRegistry (模块注册表)
│   ├── BulletProgramProcessor (编程处理器)
│   ├── EnergyCalculator (能量计算器)
│   └── BumperTemplateFactory (缓冲器模板工厂)
├── 物理层
│   ├── BulletPhysics (子弹物理)
│   ├── AOERingPhysics (AOE圆环物理)
│   ├── TrajectoryPredictor (轨迹预测)
│   └── CollisionManager (碰撞管理器)
└── 表现层
    ├── GameRenderer (游戏渲染器)
    ├── InputController (输入控制器)
    ├── BulletProgramEditorUI (编程编辑器UI)
    └── LotteryWheelUI (转盘抽奖UI)
```

### 数据流

```
用户输入 → InputController → GameEngine → 更新GameState
                                    ↓
                            物理系统/碰撞检测
                                    ↓
                            更新后的GameState → GameRenderer → Canvas显示
```

---

## 实现流程

### 阶段1: 核心数据结构

1. 定义基础类型 (Vector2, Size)
2. 定义游戏实体 (Player, Brick, Bullet, Marble)
3. 定义子弹编程 (BulletModule, BulletProgram)
4. 定义缓冲器系统 (Bumper, BumperArrayTemplate)
5. 定义游戏状态 (GameState)

### 阶段2: 游戏引擎

1. 实现事件管理器 (EventManager)
2. 实现游戏状态工厂 (GameStateFactory)
3. 实现游戏引擎主循环 (GameEngine)
4. 实现各阶段事件处理逻辑

### 阶段3: 物理系统

1. 实现物理工具函数 (距离、归一化、反射等)
2. 实现子弹物理系统 (BulletPhysics)
3. 实现AOE圆环系统 (AOERingPhysics)
4. 实现碰撞检测管理器 (CollisionManager)
5. 实现轨迹预测系统 (TrajectoryPredictor)

### 阶段4: 渲染系统

1. 实现Canvas渲染器 (GameRenderer)
2. 实现各实体的绘制方法
3. 实现UI信息显示
4. 实现动画效果（闪烁、扩展等）

### 阶段5: 交互系统

1. 实现输入控制器 (InputController)
2. 实现鼠标/触摸事件处理
3. 实现子弹编程编辑器UI
4. 实现转盘抽奖UI

### 阶段6: 游戏逻辑

1. 实现模块注册表 (BulletModuleRegistry)
2. 实现编程处理器 (BulletProgramProcessor)
3. 实现能量计算器 (EnergyCalculator)
4. 实现缓冲器模板工厂 (BumperTemplateFactory)

---

## 详细伪代码

详细的伪代码已分别记录在以下文档中：

1. **PSEUDOCODE_ARCHITECTURE.md** - 核心架构和数据结构
   - 游戏整体架构
   - 核心数据结构
   - 模块注册表
   - 能量计算器
   - 子弹编程处理器
   - 缓冲器模板配置

2. **PSEUDOCODE_ENGINE.md** - 游戏引擎和事件系统
   - 事件管理器
   - 游戏状态工厂
   - 游戏引擎主循环
   - 各阶段事件处理

3. **PSEUDOCODE_PHYSICS.md** - 物理系统和碰撞检测
   - 物理工具函数
   - 子弹物理系统
   - AOE圆环系统
   - 轨迹预测系统
   - 碰撞检测管理器
   - 物理常量配置

4. **PSEUDOCODE_UI.md** - UI渲染和交互逻辑
   - Canvas渲染器
   - 输入控制器
   - 子弹编程编辑器UI
   - 转盘抽奖UI

---

## 配置参数

### 画布配置
```
画布宽度 = 450像素
画布高度 = 800像素
网格大小 = 40像素
```

### 玩家配置
```
初始生命值 = 3
玩家位置 = (画布宽度/2, 画布高度-50)
```

### 砖块配置
```
砖块宽度 = 70像素
砖块高度 = 30像素
砖块间距 = 10像素
每行砖块数 = 5
砖块生命值 = 回合数 × 2
```

### 子弹配置
```
子弹速度 = 400像素/秒
子弹半径 = 8像素
子弹伤害 = 10
穿透伤害CD = 100毫秒
```

### 弹珠配置
```
弹珠半径 = 8像素
弹珠重力 = 500像素/秒²
弹珠初始速度X = 随机(-50, 50)像素/秒
弹珠反弹衰减 = 0.85
边界反弹衰减 = 0.9
```

### 缓冲器配置
```
缓冲器半径 = 20像素
缓冲器基础冷却 = 500毫秒
奖励缓冲器半径 = 25像素
```

### AOE配置
```
AOE最大半径 = 100像素
AOE扩展速度 = 200像素/秒
AOE伤害 = 5
```

### 能量配置
```
每个模块基础能量 = 10
空槽充能效率 = 100%
满槽充能效率 = 80%
```

### 子弹槽配置
```
子弹槽数量 = 3
槽位宽度 = 100像素
槽位高度 = 80像素
槽位间距 = 20像素
```

---

## 扩展建议

### 1. 更多模块类型

**基础子弹扩展**:
- 追踪子弹: 自动追踪最近的砖块
- 分裂子弹: 碰撞后分裂成多个小子弹
- 冰冻子弹: 减缓砖块下落速度
- 毒性子弹: 持续造成伤害

**修饰模块扩展**:
- 加速模块: 提升子弹速度
- 巨大化: 增加子弹体积和伤害
- 连锁反应: 摧毁砖块时触发连锁
- 生命汲取: 造成伤害时回复生命

### 2. 更多缓冲器模板

```
模板1: 标准阵列 (当前实现)
模板2: 金字塔阵列 (中心密集)
模板3: 螺旋阵列 (螺旋排列)
模板4: 随机阵列 (每次随机生成)
模板5: 专精阵列 (只有特定类型模块)
```

### 3. 砖块类型

- 普通砖块: 基础砖块
- 装甲砖块: 高生命值
- 爆炸砖块: 摧毁时产生AOE
- 分裂砖块: 摧毁时分裂成小砖块
- 传送砖块: 子弹穿过时传送到另一位置
- Boss砖块: 超高生命值，特殊奖励

### 4. 进阶系统

**升级系统**:
- 玩家等级
- 模块升级（提升效果）
- 槽位升级（增加容量）
- 缓冲器升级（减少冷却）

**成就系统**:
- 连击成就
- 生存成就
- 收集成就
- 特殊玩法成就

**商店系统**:
- 用分数购买模块
- 购买额外槽位
- 购买生命值
- 购买特殊道具

**天赋系统**:
- 攻击天赋（增加伤害）
- 防御天赋（增加生命）
- 能量天赋（提升能量效率）
- 幸运天赋（提升稀有度）

### 5. 视觉效果增强

- 粒子效果（碰撞、爆炸）
- 屏幕震动（强力攻击）
- 慢动作效果（关键时刻）
- 连击特效（连续击杀）
- 背景音效和音乐

### 6. 难度系统

**难度模式**:
- 简单: 砖块生命值×0.5，玩家生命值×2
- 普通: 标准配置
- 困难: 砖块生命值×1.5，玩家生命值×0.5
- 地狱: 砖块生命值×2，玩家生命值×0.3

**无尽模式**:
- 砖块生命值随回合递增
- 定期出现Boss砖块
- 排行榜系统

### 7. 多人模式

- 合作模式: 两名玩家共同防守
- 对战模式: 互相发送砖块干扰
- 排行榜: 全球分数排名

---

## 实现语言建议

### Web前端 (当前实现)
- **语言**: TypeScript + React
- **渲染**: HTML5 Canvas
- **优势**: 跨平台，易于分享
- **适合**: 快速原型，Web游戏

### 游戏引擎
- **Unity (C#)**: 强大的2D/3D支持，丰富的资源
- **Godot (GDScript)**: 开源免费，轻量级
- **Cocos2d-x (C++)**: 专注2D游戏，性能优秀

### 移动端
- **Flutter (Dart)**: 跨平台，流畅动画
- **React Native**: 复用Web代码
- **原生开发**: Swift(iOS) / Kotlin(Android)

### 桌面端
- **Electron**: 复用Web代码
- **PyGame (Python)**: 简单易学，适合初学者
- **SDL (C++)**: 底层控制，高性能

---

## 总结

这个游戏的核心创新在于**子弹编程系统**和**缓冲阵列机制**的结合，创造了独特的玩法体验。通过事件驱动架构，游戏节奏流畅自然。能量系统和模块库存管理增加了策略深度。

伪代码已经详细记录了所有核心系统的实现逻辑，你可以根据自己的技术栈选择合适的语言和框架来实现。建议按照以下顺序开发：

1. 先实现核心数据结构和游戏引擎
2. 再实现物理系统和碰撞检测
3. 然后实现基础渲染
4. 最后完善UI和交互

祝你开发顺利！如有任何问题，随时参考详细伪代码文档。
