# 弹珠编程打砖块游戏 - 游戏引擎和事件系统伪代码

## 1. 事件管理器 (EventManager)

```
类 EventManager:
    属性:
        当前事件: GameEventType
        事件监听器列表: Map<GameEventType, Array<回调函数>>
    
    方法 初始化():
        当前事件 = BRICK_SPAWN
        事件监听器列表 = 空Map
    
    方法 切换到下一个事件():
        根据 当前事件:
            当 BRICK_SPAWN:
                当前事件 = BULLET_LOADING
            当 BULLET_LOADING:
                当前事件 = PLAYER_ACTION
            当 PLAYER_ACTION:
                当前事件 = BRICK_ACTION
            当 BRICK_ACTION:
                当前事件 = BRICK_SPAWN
            当 GAME_OVER:
                // 保持在游戏结束状态
                返回
        
        触发事件(当前事件)
    
    方法 注册监听器(事件类型: GameEventType, 回调: 函数):
        如果 事件监听器列表 中不存在 事件类型:
            事件监听器列表[事件类型] = []
        事件监听器列表[事件类型].添加(回调)
    
    方法 触发事件(事件类型: GameEventType, 数据: 任意 = null):
        如果 事件监听器列表 中存在 事件类型:
            对于 事件监听器列表[事件类型] 中的每个 回调:
                回调(数据)
    
    方法 获取当前事件() -> GameEventType:
        返回 当前事件
```

## 2. 游戏状态工厂 (GameStateFactory)

```
类 GameStateFactory:
    常量 画布宽度 = 450
    常量 画布高度 = 800
    常量 网格大小 = 40
    常量 玩家初始生命值 = 3
    
    静态方法 创建初始状态() -> GameState:
        // 创建玩家
        玩家 = {
            位置: {x: 画布宽度 / 2, y: 画布高度 - 50},
            生命值: 玩家初始生命值,
            最大生命值: 玩家初始生命值,
            当前子弹槽索引: 0
        }
        
        // 创建子弹槽
        子弹槽数量 = 3
        槽位宽度 = 100
        槽位间距 = 20
        总宽度 = 子弹槽数量 * 槽位宽度 + (子弹槽数量 - 1) * 槽位间距
        起始X = (画布宽度 - 总宽度) / 2
        
        子弹槽列表 = []
        对于 i 从 0 到 子弹槽数量 - 1:
            子弹槽列表.添加({
                ID: "slot_" + i,
                名称: "槽位 " + (i + 1),
                位置: {
                    x: 起始X + i * (槽位宽度 + 槽位间距),
                    y: 画布高度 - 150
                },
                宽度: 槽位宽度,
                编程序列: {模块列表: []},
                当前能量: 0,
                单次发射能量消耗: 0
            })
        
        // 创建缓冲器阵列
        模板 = BumperTemplateFactory.创建默认模板()
        缓冲器列表 = []
        对于 模板.默认缓冲器列表 中的每个 缓冲器配置:
            缓冲器列表.添加({
                ID: 生成唯一ID(),
                位置: 缓冲器配置.位置,
                模块: 缓冲器配置.模块,
                当前冷却时间: 0,
                基础冷却时间: 500,  // 500毫秒
                被击中次数: 0
            })
        
        // 创建奖励缓冲器
        奖励缓冲器列表 = []
        对于 模板.奖励缓冲器位置列表 中的每个 位置配置:
            奖励缓冲器列表.添加({
                ID: 生成唯一ID(),
                类型: 位置配置.类型,
                位置: {x: 位置配置.x, y: 位置配置.y},
                是否固定: true,
                闪烁相位: 0,
                是否已触发: false
            })
        
        // 初始化模块库存
        模块库存 = {}
        对于 BulletModuleRegistry.获取所有模块() 中的每个 模块:
            模块库存[模块.类型] = 5  // 每种模块初始5个
        
        返回 {
            当前事件: BRICK_SPAWN,
            玩家: 玩家,
            砖块列表: [],
            子弹列表: [],
            AOE圆环列表: [],
            缓冲器阵列: 缓冲器列表,
            奖励缓冲器列表: 奖励缓冲器列表,
            子弹槽列表: 子弹槽列表,
            弹珠列表: [],
            当前缓冲器模板: 模板,
            模块库存: 模块库存,
            回合数: 1,
            分数: 0,
            游戏结束标志: false,
            错误消息: null,
            调试日志: [],
            瞄准轨迹: null,
            瞄准方向: null,
            网格大小: 网格大小,
            弹珠发射模式: '自动',
            手动发射方向: null,
            待发射弹珠数量: 0,
            抽奖状态: {
                是否激活: false,
                奖池模块列表: []
            }
        }
```

## 3. 游戏引擎 (GameEngine)

```
类 GameEngine:
    属性:
        状态: GameState
        事件管理器: EventManager
        上次更新时间: 时间戳
        是否运行中: 布尔值
    
    方法 初始化():
        状态 = GameStateFactory.创建初始状态()
        事件管理器 = 新建 EventManager()
        事件管理器.初始化()
        
        // 注册事件监听器
        事件管理器.注册监听器(BRICK_SPAWN, 处理砖块生成)
        事件管理器.注册监听器(BULLET_LOADING, 处理子弹装填)
        事件管理器.注册监听器(PLAYER_ACTION, 处理玩家行动)
        事件管理器.注册监听器(BRICK_ACTION, 处理砖块行动)
        
        上次更新时间 = 当前时间()
        是否运行中 = false
    
    方法 开始():
        是否运行中 = true
        事件管理器.触发事件(BRICK_SPAWN)
    
    方法 更新(当前时间: 时间戳):
        如果 not 是否运行中 或 状态.游戏结束标志:
            返回
        
        时间差 = 当前时间 - 上次更新时间
        上次更新时间 = 当前时间
        
        // 根据当前事件更新不同系统
        根据 状态.当前事件:
            当 BULLET_LOADING:
                更新弹珠物理(时间差)
                更新缓冲器冷却(时间差)
            当 PLAYER_ACTION:
                更新子弹物理(时间差)
                更新AOE圆环(时间差)
                检测子弹砖块碰撞()
                清理越界子弹()
            当 BRICK_ACTION:
                // 砖块行动在事件触发时处理
                无操作
    
    方法 处理砖块生成():
        // 生成新一行砖块
        砖块行数 = 1
        每行砖块数 = 5
        砖块宽度 = 70
        砖块高度 = 30
        砖块间距 = 10
        
        对于 i 从 0 到 每行砖块数 - 1:
            砖块 = {
                ID: 生成唯一ID(),
                位置: {
                    x: 50 + i * (砖块宽度 + 砖块间距),
                    y: 50
                },
                尺寸: {宽度: 砖块宽度, 高度: 砖块高度},
                生命值: 状态.回合数 * 2,  // 生命值随回合增加
                最大生命值: 状态.回合数 * 2,
                所在行: 0
            }
            状态.砖块列表.添加(砖块)
    
    方法 处理子弹装填():
        // 生成弹珠
        弹珠数量 = 3
        对于 i 从 0 到 弹珠数量 - 1:
            弹珠 = {
                ID: 生成唯一ID(),
                位置: {x: 画布宽度 / 2, y: 50},
                速度: {
                    x: 随机数(-50, 50),
                    y: 0
                },
                半径: 8,
                状态: FALLING,
                收集的模块列表: [],
                碰撞次数: 0
            }
            状态.弹珠列表.添加(弹珠)
            
            // 延迟发射
            延迟(i * 500毫秒)
    
    方法 处理玩家行动():
        // 玩家可以发射子弹
        // 由UI交互触发
        无操作
    
    方法 处理砖块行动():
        // 所有砖块下落一格
        对于 状态.砖块列表 中的每个 砖块:
            砖块.位置.y += 状态.网格大小
            砖块.所在行 += 1
            
            // 检查是否触及底部
            如果 砖块.位置.y + 砖块.尺寸.高度 >= 玩家位置.y:
                状态.玩家.生命值 -= 1
                从 状态.砖块列表 中移除 砖块
                
                如果 状态.玩家.生命值 <= 0:
                    状态.游戏结束标志 = true
                    状态.当前事件 = GAME_OVER
        
        // 进入下一回合
        如果 not 状态.游戏结束标志:
            状态.回合数 += 1
    
    方法 更新弹珠物理(时间差: 浮点数):
        重力 = 500  // 像素/秒²
        
        对于 状态.弹珠列表 中的每个 弹珠:
            如果 弹珠.状态 != FALLING:
                继续下一个
            
            // 应用重力
            弹珠.速度.y += 重力 * 时间差 / 1000
            
            // 更新位置
            弹珠.位置.x += 弹珠.速度.x * 时间差 / 1000
            弹珠.位置.y += 弹珠.速度.y * 时间差 / 1000
            
            // 边界碰撞
            如果 弹珠.位置.x - 弹珠.半径 < 0:
                弹珠.位置.x = 弹珠.半径
                弹珠.速度.x = -弹珠.速度.x * 0.8  // 能量衰减
            如果 弹珠.位置.x + 弹珠.半径 > 画布宽度:
                弹珠.位置.x = 画布宽度 - 弹珠.半径
                弹珠.速度.x = -弹珠.速度.x * 0.8
            
            // 检测与缓冲器碰撞
            检测弹珠缓冲器碰撞(弹珠)
            
            // 检测与子弹槽碰撞
            检测弹珠槽位碰撞(弹珠)
            
            // 检测越界
            如果 弹珠.位置.y > 画布高度:
                弹珠.状态 = OUT_OF_BOUNDS
    
    方法 检测弹珠缓冲器碰撞(弹珠: Marble):
        对于 状态.缓冲器阵列 中的每个 缓冲器:
            如果 缓冲器.当前冷却时间 > 0:
                继续下一个
            
            距离 = 计算距离(弹珠.位置, 缓冲器.位置)
            缓冲器半径 = 20
            
            如果 距离 < 弹珠.半径 + 缓冲器半径:
                // 碰撞发生
                弹珠.收集的模块列表.添加(缓冲器.模块)
                
                // 反弹
                方向 = 归一化(弹珠.位置 - 缓冲器.位置)
                弹珠.速度 = 方向 * 200  // 反弹速度
                
                // 设置冷却
                缓冲器.当前冷却时间 = 缓冲器.基础冷却时间
                缓冲器.被击中次数 += 1
                
                // 能量衰减
                弹珠.碰撞次数 += 1
                衰减系数 = 0.85 的 弹珠.碰撞次数 次方
                弹珠.速度 *= 衰减系数
        
        // 检测奖励缓冲器
        对于 状态.奖励缓冲器列表 中的每个 奖励缓冲器:
            如果 奖励缓冲器.是否已触发:
                继续下一个
            
            距离 = 计算距离(弹珠.位置, 奖励缓冲器.位置)
            如果 距离 < 弹珠.半径 + 25:
                // 触发抽奖
                奖励缓冲器.是否已触发 = true
                触发抽奖(弹珠.收集的模块列表)
    
    方法 检测弹珠槽位碰撞(弹珠: Marble):
        对于 状态.子弹槽列表 中的每个 槽位:
            如果 弹珠.位置.x >= 槽位.位置.x 且
               弹珠.位置.x <= 槽位.位置.x + 槽位.宽度 且
               弹珠.位置.y >= 槽位.位置.y 且
               弹珠.位置.y <= 槽位.位置.y + 80:
                // 弹珠落入槽位
                弹珠.状态 = IN_SLOT
                弹珠.目标槽位 = 槽位.ID
                
                // 处理模块和能量
                处理弹珠落入槽位(弹珠, 槽位)
                跳出循环
    
    方法 处理弹珠落入槽位(弹珠: Marble, 槽位: BulletSlot):
        如果 槽位.编程序列.模块列表.长度 == 0:
            // 空槽: 创建新编程
            槽位.编程序列.模块列表 = 弹珠.收集的模块列表
            获得能量 = EnergyCalculator.计算装填获得能量(
                弹珠.收集的模块列表, 
                true
            )
            槽位.当前能量 += 获得能量
            槽位.单次发射能量消耗 = EnergyCalculator.计算编程消耗(槽位.编程序列)
        否则:
            // 满槽: 转化为能量
            获得能量 = EnergyCalculator.计算装填获得能量(
                弹珠.收集的模块列表, 
                false
            )
            槽位.当前能量 += 获得能量
    
    方法 触发抽奖(候选模块列表: Array<BulletModule>):
        如果 候选模块列表.长度 == 0:
            返回
        
        状态.抽奖状态.是否激活 = true
        状态.抽奖状态.奖池模块列表 = 候选模块列表
        
        // UI会显示转盘动画，用户确认后调用 完成抽奖()
    
    方法 完成抽奖(选中模块: BulletModule):
        // 将模块添加到库存
        状态.模块库存[选中模块.类型] += 1
        状态.抽奖状态.是否激活 = false
        状态.抽奖状态.奖池模块列表 = []
    
    方法 发射子弹(槽位索引: 整数):
        槽位 = 状态.子弹槽列表[槽位索引]
        
        // 检查能量是否足够
        如果 槽位.当前能量 < 槽位.单次发射能量消耗:
            状态.错误消息 = "能量不足"
            返回
        
        // 验证编程
        验证结果 = BulletProgramProcessor.验证编程(槽位.编程序列)
        如果 not 验证结果.有效:
            状态.错误消息 = 验证结果.错误
            返回
        
        // 消耗能量
        槽位.当前能量 -= 槽位.单次发射能量消耗
        
        // 解析编程
        解析结果 = BulletProgramProcessor.解析编程(槽位.编程序列)
        
        // 创建子弹
        基础子弹 = {
            ID: 生成唯一ID(),
            位置: {x: 状态.玩家.位置.x, y: 状态.玩家.位置.y - 20},
            速度: 状态.瞄准方向 * 400,  // 400像素/秒
            编程序列: 槽位.编程序列,
            剩余反弹次数: 解析结果.反弹次数,
            伤害: 10,
            半径: 8
        }
        状态.子弹列表.添加(基础子弹)
        
        // 处理散射
        对于 i 从 1 到 解析结果.散射数量:
            散射角度 = 15度 * i
            散射子弹 = 复制(基础子弹)
            散射子弹.ID = 生成唯一ID()
            散射子弹.速度 = 旋转向量(基础子弹.速度, 散射角度)
            状态.子弹列表.添加(散射子弹)
            
            散射子弹2 = 复制(基础子弹)
            散射子弹2.ID = 生成唯一ID()
            散射子弹2.速度 = 旋转向量(基础子弹.速度, -散射角度)
            状态.子弹列表.添加(散射子弹2)
        
        // 处理齐射
        对于 i 从 1 到 解析结果.齐射数量:
            齐射子弹 = 复制(基础子弹)
            齐射子弹.ID = 生成唯一ID()
            齐射子弹.位置.x += i * 15
            状态.子弹列表.添加(齐射子弹)
            
            齐射子弹2 = 复制(基础子弹)
            齐射子弹2.ID = 生成唯一ID()
            齐射子弹2.位置.x -= i * 15
            状态.子弹列表.添加(齐射子弹2)
    
    方法 切换到下一个事件():
        事件管理器.切换到下一个事件()
        状态.当前事件 = 事件管理器.获取当前事件()
    
    方法 获取状态() -> GameState:
        返回 状态
```

这是游戏引擎和事件系统的核心伪代码。接下来我会继续记录物理系统和碰撞检测逻辑。
