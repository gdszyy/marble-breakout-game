# 弹珠编程打砖块游戏 - UI渲染和交互逻辑伪代码

## 1. Canvas渲染器

```
类 GameRenderer:
    属性:
        画布: Canvas元素
        上下文: 2D渲染上下文
        画布宽度: 整数
        画布高度: 整数
    
    方法 初始化(画布元素: HTMLCanvasElement):
        画布 = 画布元素
        上下文 = 画布.获取2D上下文()
        画布宽度 = 画布.宽度
        画布高度 = 画布.高度
    
    方法 渲染(状态: GameState):
        // 清空画布
        上下文.清空矩形(0, 0, 画布宽度, 画布高度)
        
        // 绘制背景
        绘制背景()
        
        // 根据当前事件渲染不同内容
        根据 状态.当前事件:
            当 BRICK_SPAWN:
                绘制砖块生成阶段(状态)
            当 BULLET_LOADING:
                绘制子弹装填阶段(状态)
            当 PLAYER_ACTION:
                绘制玩家行动阶段(状态)
            当 BRICK_ACTION:
                绘制砖块行动阶段(状态)
            当 GAME_OVER:
                绘制游戏结束界面(状态)
        
        // 绘制UI信息
        绘制UI信息(状态)
    
    方法 绘制背景():
        // 绘制渐变背景
        渐变 = 上下文.创建线性渐变(0, 0, 0, 画布高度)
        渐变.添加颜色停止(0, "#1a1a2e")
        渐变.添加颜色停止(1, "#16213e")
        
        上下文.填充样式 = 渐变
        上下文.填充矩形(0, 0, 画布宽度, 画布高度)
    
    方法 绘制砖块生成阶段(状态: GameState):
        绘制砖块列表(状态.砖块列表)
        绘制玩家(状态.玩家)
        绘制子弹槽列表(状态.子弹槽列表, 状态.玩家.当前子弹槽索引)
        
        // 显示提示文字
        上下文.字体 = "20px Arial"
        上下文.填充样式 = "#ffffff"
        上下文.文本对齐 = "center"
        上下文.填充文本("新的晶石魔像出现了！", 画布宽度 / 2, 画布高度 / 2)
    
    方法 绘制子弹装填阶段(状态: GameState):
        绘制砖块列表(状态.砖块列表)
        绘制缓冲器阵列(状态.缓冲器阵列)
        绘制奖励缓冲器列表(状态.奖励缓冲器列表)
        绘制弹珠列表(状态.弹珠列表)
        绘制子弹槽列表(状态.子弹槽列表, 状态.玩家.当前子弹槽索引)
        绘制玩家(状态.玩家)
        
        // 如果有抽奖，绘制转盘
        如果 状态.抽奖状态.是否激活:
            绘制转盘(状态.抽奖状态.奖池模块列表)
    
    方法 绘制玩家行动阶段(状态: GameState):
        绘制砖块列表(状态.砖块列表)
        绘制子弹列表(状态.子弹列表)
        绘制AOE圆环列表(状态.AOE圆环列表)
        绘制玩家(状态.玩家)
        绘制子弹槽列表(状态.子弹槽列表, 状态.玩家.当前子弹槽索引)
        
        // 绘制瞄准轨迹
        如果 状态.瞄准轨迹 != null:
            绘制轨迹(状态.瞄准轨迹)
    
    方法 绘制砖块行动阶段(状态: GameState):
        绘制砖块列表(状态.砖块列表)
        绘制玩家(状态.玩家)
        绘制子弹槽列表(状态.子弹槽列表, 状态.玩家.当前子弹槽索引)
        
        // 显示提示文字
        上下文.字体 = "20px Arial"
        上下文.填充样式 = "#ffffff"
        上下文.文本对齐 = "center"
        上下文.填充文本("魔像逼近了！", 画布宽度 / 2, 画布高度 / 2)
    
    方法 绘制玩家(玩家: Player):
        // 绘制玩家为三角形
        上下文.开始路径()
        上下文.移动到(玩家.位置.x, 玩家.位置.y - 15)
        上下文.连线到(玩家.位置.x - 15, 玩家.位置.y + 15)
        上下文.连线到(玩家.位置.x + 15, 玩家.位置.y + 15)
        上下文.闭合路径()
        
        上下文.填充样式 = "#00d4ff"
        上下文.填充()
        上下文.描边样式 = "#ffffff"
        上下文.线宽 = 2
        上下文.描边()
    
    方法 绘制砖块列表(砖块列表: Array<Brick>):
        对于 砖块列表 中的每个 砖块:
            绘制砖块(砖块)
    
    方法 绘制砖块(砖块: Brick):
        // 根据生命值计算颜色
        生命值百分比 = 砖块.生命值 / 砖块.最大生命值
        颜色 = 插值颜色("#ff6b6b", "#ff0000", 1 - 生命值百分比)
        
        // 绘制砖块矩形
        上下文.填充样式 = 颜色
        上下文.填充矩形(
            砖块.位置.x,
            砖块.位置.y,
            砖块.尺寸.宽度,
            砖块.尺寸.高度
        )
        
        // 绘制边框
        上下文.描边样式 = "#ffffff"
        上下文.线宽 = 2
        上下文.描边矩形(
            砖块.位置.x,
            砖块.位置.y,
            砖块.尺寸.宽度,
            砖块.尺寸.高度
        )
        
        // 绘制生命值文字
        上下文.字体 = "14px Arial"
        上下文.填充样式 = "#ffffff"
        上下文.文本对齐 = "center"
        上下文.文本基线 = "middle"
        上下文.填充文本(
            砖块.生命值.转字符串(),
            砖块.位置.x + 砖块.尺寸.宽度 / 2,
            砖块.位置.y + 砖块.尺寸.高度 / 2
        )
    
    方法 绘制子弹列表(子弹列表: Array<Bullet>):
        对于 子弹列表 中的每个 子弹:
            绘制子弹(子弹)
    
    方法 绘制子弹(子弹: Bullet):
        // 根据子弹类型选择颜色
        解析结果 = BulletProgramProcessor.解析编程(子弹.编程序列)
        
        颜色 = 根据 解析结果.基础子弹类型:
            当 NORMAL: "#00ff00"
            当 PIERCING: "#ffff00"
            当 AOE: "#ff00ff"
            默认: "#ffffff"
        
        // 绘制子弹圆形
        上下文.开始路径()
        上下文.圆弧(
            子弹.位置.x,
            子弹.位置.y,
            子弹.半径,
            0,
            2 * PI
        )
        上下文.填充样式 = 颜色
        上下文.填充()
        
        // 绘制发光效果
        上下文.阴影模糊 = 10
        上下文.阴影颜色 = 颜色
        上下文.填充()
        上下文.阴影模糊 = 0
    
    方法 绘制AOE圆环列表(圆环列表: Array<AOERing>):
        对于 圆环列表 中的每个 圆环:
            绘制AOE圆环(圆环)
    
    方法 绘制AOE圆环(圆环: AOERing):
        // 绘制扩展的圆环
        上下文.开始路径()
        上下文.圆弧(
            圆环.位置.x,
            圆环.位置.y,
            圆环.当前半径,
            0,
            2 * PI
        )
        
        // 渐变透明度
        透明度 = 1 - (圆环.当前半径 / 圆环.最大半径)
        上下文.描边样式 = "rgba(255, 0, 255, " + 透明度 + ")"
        上下文.线宽 = 5
        上下文.描边()
        
        // 发光效果
        上下文.阴影模糊 = 20
        上下文.阴影颜色 = "#ff00ff"
        上下文.描边()
        上下文.阴影模糊 = 0
    
    方法 绘制缓冲器阵列(缓冲器列表: Array<Bumper>):
        对于 缓冲器列表 中的每个 缓冲器:
            绘制缓冲器(缓冲器)
    
    方法 绘制缓冲器(缓冲器: Bumper):
        // 绘制缓冲器圆形
        上下文.开始路径()
        上下文.圆弧(
            缓冲器.位置.x,
            缓冲器.位置.y,
            20,
            0,
            2 * PI
        )
        
        // 根据冷却状态改变颜色
        如果 缓冲器.当前冷却时间 > 0:
            上下文.填充样式 = "#666666"
        否则:
            上下文.填充样式 = "#4ecdc4"
        
        上下文.填充()
        上下文.描边样式 = "#ffffff"
        上下文.线宽 = 2
        上下文.描边()
        
        // 绘制模块图标
        绘制模块图标(缓冲器.模块, 缓冲器.位置.x, 缓冲器.位置.y, 16)
    
    方法 绘制奖励缓冲器列表(奖励缓冲器列表: Array<RewardBumper>):
        对于 奖励缓冲器列表 中的每个 奖励缓冲器:
            如果 not 奖励缓冲器.是否已触发:
                绘制奖励缓冲器(奖励缓冲器)
    
    方法 绘制奖励缓冲器(奖励缓冲器: RewardBumper):
        // 绘制金色闪烁的缓冲器
        上下文.开始路径()
        上下文.圆弧(
            奖励缓冲器.位置.x,
            奖励缓冲器.位置.y,
            25,
            0,
            2 * PI
        )
        
        // 闪烁效果
        闪烁强度 = 0.5 + 0.5 * 正弦(奖励缓冲器.闪烁相位 * 2 * PI)
        上下文.填充样式 = "rgba(255, 215, 0, " + 闪烁强度 + ")"
        上下文.填充()
        
        // 发光效果
        上下文.阴影模糊 = 20
        上下文.阴影颜色 = "#ffd700"
        上下文.填充()
        上下文.阴影模糊 = 0
        
        // 绘制礼物盒图标
        上下文.字体 = "20px Arial"
        上下文.填充样式 = "#ffffff"
        上下文.文本对齐 = "center"
        上下文.文本基线 = "middle"
        上下文.填充文本("🎁", 奖励缓冲器.位置.x, 奖励缓冲器.位置.y)
        
        // 更新闪烁相位
        奖励缓冲器.闪烁相位 = (奖励缓冲器.闪烁相位 + 0.02) % 1
    
    方法 绘制弹珠列表(弹珠列表: Array<Marble>):
        对于 弹珠列表 中的每个 弹珠:
            如果 弹珠.状态 == FALLING:
                绘制弹珠(弹珠)
    
    方法 绘制弹珠(弹珠: Marble):
        // 绘制弹珠
        上下文.开始路径()
        上下文.圆弧(
            弹珠.位置.x,
            弹珠.位置.y,
            弹珠.半径,
            0,
            2 * PI
        )
        上下文.填充样式 = "#ffffff"
        上下文.填充()
        上下文.描边样式 = "#00d4ff"
        上下文.线宽 = 2
        上下文.描边()
        
        // 绘制收集的模块数量
        如果 弹珠.收集的模块列表.长度 > 0:
            上下文.字体 = "10px Arial"
            上下文.填充样式 = "#ff0000"
            上下文.文本对齐 = "center"
            上下文.文本基线 = "middle"
            上下文.填充文本(
                弹珠.收集的模块列表.长度.转字符串(),
                弹珠.位置.x,
                弹珠.位置.y
            )
    
    方法 绘制子弹槽列表(子弹槽列表: Array<BulletSlot>, 当前槽位索引: 整数):
        对于 i 从 0 到 子弹槽列表.长度 - 1:
            槽位 = 子弹槽列表[i]
            是否选中 = (i == 当前槽位索引)
            绘制子弹槽(槽位, 是否选中)
    
    方法 绘制子弹槽(槽位: BulletSlot, 是否选中: 布尔值):
        // 绘制槽位背景
        上下文.填充样式 = 是否选中 ? "#4ecdc4" : "#2a2a3e"
        上下文.填充矩形(
            槽位.位置.x,
            槽位.位置.y,
            槽位.宽度,
            80
        )
        
        // 绘制边框
        上下文.描边样式 = 是否选中 ? "#00d4ff" : "#ffffff"
        上下文.线宽 = 是否选中 ? 3 : 1
        上下文.描边矩形(
            槽位.位置.x,
            槽位.位置.y,
            槽位.宽度,
            80
        )
        
        // 绘制槽位名称
        上下文.字体 = "12px Arial"
        上下文.填充样式 = "#ffffff"
        上下文.文本对齐 = "center"
        上下文.填充文本(
            槽位.名称,
            槽位.位置.x + 槽位.宽度 / 2,
            槽位.位置.y + 15
        )
        
        // 绘制编程模块
        如果 槽位.编程序列.模块列表.长度 > 0:
            模块起始X = 槽位.位置.x + 10
            模块Y = 槽位.位置.y + 35
            
            对于 i 从 0 到 槽位.编程序列.模块列表.长度 - 1:
                模块 = 槽位.编程序列.模块列表[i]
                绘制模块图标(模块, 模块起始X + i * 20, 模块Y, 16)
        
        // 绘制能量信息
        可发射次数 = EnergyCalculator.计算可发射次数(
            槽位.当前能量,
            槽位.单次发射能量消耗
        )
        能量进度 = EnergyCalculator.计算能量进度(
            槽位.当前能量,
            槽位.单次发射能量消耗
        )
        
        上下文.字体 = "10px Arial"
        上下文.填充样式 = "#ffffff"
        上下文.文本对齐 = "left"
        上下文.填充文本(
            "x" + 可发射次数,
            槽位.位置.x + 5,
            槽位.位置.y + 70
        )
        
        // 绘制能量进度条
        进度条宽度 = 槽位.宽度 - 40
        上下文.填充样式 = "#666666"
        上下文.填充矩形(
            槽位.位置.x + 35,
            槽位.位置.y + 62,
            进度条宽度,
            6
        )
        
        上下文.填充样式 = "#00ff00"
        上下文.填充矩形(
            槽位.位置.x + 35,
            槽位.位置.y + 62,
            进度条宽度 * 能量进度,
            6
        )
    
    方法 绘制轨迹(轨迹点列表: Array<Vector2>):
        如果 轨迹点列表.长度 < 2:
            返回
        
        上下文.开始路径()
        上下文.移动到(轨迹点列表[0].x, 轨迹点列表[0].y)
        
        对于 i 从 1 到 轨迹点列表.长度 - 1:
            上下文.连线到(轨迹点列表[i].x, 轨迹点列表[i].y)
        
        上下文.描边样式 = "rgba(255, 255, 255, 0.5)"
        上下文.线宽 = 2
        上下文.设置虚线([5, 5])
        上下文.描边()
        上下文.设置虚线([])
    
    方法 绘制UI信息(状态: GameState):
        // 绘制顶部信息栏
        上下文.填充样式 = "rgba(0, 0, 0, 0.5)"
        上下文.填充矩形(0, 0, 画布宽度, 40)
        
        // 生命值
        上下文.字体 = "16px Arial"
        上下文.填充样式 = "#ffffff"
        上下文.文本对齐 = "left"
        上下文.填充文本(
            "生命: " + 状态.玩家.生命值 + "/" + 状态.玩家.最大生命值,
            10,
            25
        )
        
        // 回合数
        上下文.文本对齐 = "center"
        上下文.填充文本(
            "回合: " + 状态.回合数,
            画布宽度 / 2,
            25
        )
        
        // 分数
        上下文.文本对齐 = "right"
        上下文.填充文本(
            "分数: " + 状态.分数,
            画布宽度 - 10,
            25
        )
        
        // 当前事件提示
        事件文本 = 根据 状态.当前事件:
            当 BRICK_SPAWN: "砖块生成"
            当 BULLET_LOADING: "子弹装填"
            当 PLAYER_ACTION: "玩家行动"
            当 BRICK_ACTION: "砖块行动"
            当 GAME_OVER: "游戏结束"
        
        上下文.字体 = "14px Arial"
        上下文.填充样式 = "#00d4ff"
        上下文.文本对齐 = "center"
        上下文.填充文本(
            事件文本,
            画布宽度 / 2,
            画布高度 - 10
        )
    
    方法 绘制模块图标(模块: BulletModule, x: 整数, y: 整数, 大小: 整数):
        // 根据模块类型绘制不同图标
        图标 = 根据 模块.类型:
            当 NORMAL: "⚪"
            当 PIERCING: "➤"
            当 AOE: "💥"
            当 BOUNCE_PLUS: "↗"
            当 SCATTER_PLUS: "↗↗"
            当 VOLLEY_PLUS: "|||"
            当 COLLISION_TRIGGER: "⚡"
            默认: "?"
        
        上下文.字体 = 大小 + "px Arial"
        上下文.文本对齐 = "center"
        上下文.文本基线 = "middle"
        上下文.填充文本(图标, x, y)
```

## 2. 输入控制器

```
类 InputController:
    属性:
        游戏引擎: GameEngine
        画布: Canvas元素
        鼠标按下: 布尔值
        鼠标位置: Vector2
        触摸开始位置: Vector2
    
    方法 初始化(游戏引擎: GameEngine, 画布: Canvas元素):
        游戏引擎 = 游戏引擎
        画布 = 画布
        鼠标按下 = false
        
        // 注册事件监听器
        画布.添加事件监听器("mousedown", 处理鼠标按下)
        画布.添加事件监听器("mousemove", 处理鼠标移动)
        画布.添加事件监听器("mouseup", 处理鼠标松开)
        画布.添加事件监听器("touchstart", 处理触摸开始)
        画布.添加事件监听器("touchmove", 处理触摸移动)
        画布.添加事件监听器("touchend", 处理触摸结束)
    
    方法 处理鼠标按下(事件: MouseEvent):
        鼠标按下 = true
        鼠标位置 = 获取画布坐标(事件.clientX, 事件.clientY)
        
        状态 = 游戏引擎.获取状态()
        
        根据 状态.当前事件:
            当 PLAYER_ACTION:
                // 开始瞄准
                处理瞄准开始(鼠标位置)
            当 BULLET_LOADING:
                // 检测是否点击子弹槽
                处理槽位点击(鼠标位置)
    
    方法 处理鼠标移动(事件: MouseEvent):
        鼠标位置 = 获取画布坐标(事件.clientX, 事件.clientY)
        
        如果 鼠标按下:
            状态 = 游戏引擎.获取状态()
            
            如果 状态.当前事件 == PLAYER_ACTION:
                // 更新瞄准方向
                处理瞄准更新(鼠标位置)
    
    方法 处理鼠标松开(事件: MouseEvent):
        如果 not 鼠标按下:
            返回
        
        鼠标按下 = false
        鼠标位置 = 获取画布坐标(事件.clientX, 事件.clientY)
        
        状态 = 游戏引擎.获取状态()
        
        如果 状态.当前事件 == PLAYER_ACTION:
            // 发射子弹
            游戏引擎.发射子弹(状态.玩家.当前子弹槽索引)
            状态.瞄准轨迹 = null
            状态.瞄准方向 = null
    
    方法 处理瞄准开始(位置: Vector2):
        状态 = 游戏引擎.获取状态()
        玩家位置 = 状态.玩家.位置
        
        方向 = TrajectoryPredictor.计算瞄准方向(玩家位置, 位置)
        轨迹 = TrajectoryPredictor.预测轨迹(
            玩家位置,
            方向,
            400,
            画布.宽度,
            画布.高度
        )
        
        状态.瞄准方向 = 方向
        状态.瞄准轨迹 = 轨迹
    
    方法 处理瞄准更新(位置: Vector2):
        处理瞄准开始(位置)
    
    方法 处理槽位点击(位置: Vector2):
        状态 = 游戏引擎.获取状态()
        
        对于 i 从 0 到 状态.子弹槽列表.长度 - 1:
            槽位 = 状态.子弹槽列表[i]
            
            如果 矩形包含点({
                x: 槽位.位置.x,
                y: 槽位.位置.y,
                宽度: 槽位.宽度,
                高度: 80
            }, 位置):
                状态.玩家.当前子弹槽索引 = i
                跳出循环
    
    方法 获取画布坐标(屏幕X: 整数, 屏幕Y: 整数) -> Vector2:
        矩形 = 画布.获取边界矩形()
        返回 {
            x: 屏幕X - 矩形.left,
            y: 屏幕Y - 矩形.top
        }
```

## 3. 子弹编程编辑器UI

```
类 BulletProgramEditorUI:
    方法 渲染编辑器(状态: GameState) -> HTML:
        返回 HTML模板:
            <div class="编辑器容器">
                <h2>魔药配方台</h2>
                
                <!-- 子弹槽选择 -->
                <div class="槽位选择器">
                    对于 i 从 0 到 状态.子弹槽列表.长度 - 1:
                        槽位 = 状态.子弹槽列表[i]
                        是否选中 = (i == 状态.玩家.当前子弹槽索引)
                        
                        <button 
                            class={是否选中 ? "选中" : ""}
                            onclick="选择槽位(i)">
                            {槽位.名称}
                        </button>
                </div>
                
                <!-- 当前编程显示 -->
                <div class="当前编程">
                    <h3>当前配方:</h3>
                    <div class="模块列表">
                        对于 当前槽位.编程序列.模块列表 中的每个 模块:
                            <div class="模块卡片">
                                {模块图标}
                                <span>{模块.名称}</span>
                                <button onclick="移除模块(模块.ID)">×</button>
                            </div>
                    </div>
                </div>
                
                <!-- 模块库存 -->
                <div class="模块库存">
                    <h3>材料宝库:</h3>
                    <div class="库存网格">
                        对于 状态.模块库存 中的每个 (类型, 数量):
                            模块 = BulletModuleRegistry.根据类型获取模块(类型)
                            
                            <div class="库存项" onclick="添加模块(类型)">
                                {模块图标}
                                <span>{模块.名称}</span>
                                <span class="数量">x{数量}</span>
                            </div>
                    </div>
                </div>
                
                <!-- 操作按钮 -->
                <div class="操作按钮">
                    <button onclick="清空编程()">清空配方</button>
                    <button onclick="关闭编辑器()">关闭</button>
                </div>
            </div>
    
    方法 添加模块到编程(模块类型: BulletModuleType):
        状态 = 游戏引擎.获取状态()
        当前槽位 = 状态.子弹槽列表[状态.玩家.当前子弹槽索引]
        
        // 检查库存
        如果 状态.模块库存[模块类型] <= 0:
            显示错误("库存不足")
            返回
        
        // 获取模块
        模块 = BulletModuleRegistry.根据类型获取模块(模块类型)
        
        // 添加到编程
        当前槽位.编程序列.模块列表.添加(模块)
        
        // 扣除库存
        状态.模块库存[模块类型] -= 1
        
        // 更新能量消耗
        当前槽位.单次发射能量消耗 = EnergyCalculator.计算编程消耗(当前槽位.编程序列)
    
    方法 从编程移除模块(模块ID: 字符串):
        状态 = 游戏引擎.获取状态()
        当前槽位 = 状态.子弹槽列表[状态.玩家.当前子弹槽索引]
        
        // 找到并移除模块
        模块索引 = 当前槽位.编程序列.模块列表.查找索引(m => m.ID == 模块ID)
        如果 模块索引 >= 0:
            模块 = 当前槽位.编程序列.模块列表[模块索引]
            当前槽位.编程序列.模块列表.移除索引(模块索引)
            
            // 返还库存
            状态.模块库存[模块.类型] += 1
            
            // 更新能量消耗
            当前槽位.单次发射能量消耗 = EnergyCalculator.计算编程消耗(当前槽位.编程序列)
```

## 4. 转盘抽奖UI

```
类 LotteryWheelUI:
    属性:
        旋转角度: 浮点数
        是否旋转中: 布尔值
        选中模块: BulletModule
    
    方法 渲染转盘(奖池模块列表: Array<BulletModule>) -> HTML:
        返回 HTML模板:
            <div class="转盘容器">
                <h2>命运转盘</h2>
                <p>触发了贤者之触！</p>
                
                <canvas id="转盘画布" width="300" height="300"></canvas>
                
                <button onclick="开始旋转()">开始抽奖</button>
            </div>
    
    方法 绘制转盘(画布: Canvas, 奖池模块列表: Array<BulletModule>):
        上下文 = 画布.获取2D上下文()
        中心X = 150
        中心Y = 150
        半径 = 120
        
        扇形角度 = 360 / 奖池模块列表.长度
        
        对于 i 从 0 到 奖池模块列表.长度 - 1:
            模块 = 奖池模块列表[i]
            
            起始角度 = (i * 扇形角度 + 旋转角度) * PI / 180
            结束角度 = ((i + 1) * 扇形角度 + 旋转角度) * PI / 180
            
            // 绘制扇形
            上下文.开始路径()
            上下文.移动到(中心X, 中心Y)
            上下文.圆弧(中心X, 中心Y, 半径, 起始角度, 结束角度)
            上下文.闭合路径()
            
            // 交替颜色
            上下文.填充样式 = i % 2 == 0 ? "#4ecdc4" : "#ff6b6b"
            上下文.填充()
            
            // 绘制模块名称
            角度 = (起始角度 + 结束角度) / 2
            文本X = 中心X + 余弦(角度) * 半径 * 0.7
            文本Y = 中心Y + 正弦(角度) * 半径 * 0.7
            
            上下文.字体 = "14px Arial"
            上下文.填充样式 = "#ffffff"
            上下文.文本对齐 = "center"
            上下文.文本基线 = "middle"
            上下文.填充文本(模块.名称, 文本X, 文本Y)
        
        // 绘制指针
        上下文.开始路径()
        上下文.移动到(中心X, 中心Y - 半径 - 20)
        上下文.连线到(中心X - 10, 中心Y - 半径)
        上下文.连线到(中心X + 10, 中心Y - 半径)
        上下文.闭合路径()
        上下文.填充样式 = "#ffd700"
        上下文.填充()
    
    方法 开始旋转():
        如果 是否旋转中:
            返回
        
        是否旋转中 = true
        
        // 随机选择一个模块
        奖池模块列表 = 游戏引擎.获取状态().抽奖状态.奖池模块列表
        选中索引 = 随机整数(0, 奖池模块列表.长度 - 1)
        选中模块 = 奖池模块列表[选中索引]
        
        // 计算目标角度
        扇形角度 = 360 / 奖池模块列表.长度
        目标角度 = 360 * 5 + 选中索引 * 扇形角度  // 旋转5圈
        
        // 动画旋转
        动画旋转到(目标角度, 3000)  // 3秒
    
    方法 动画旋转到(目标角度: 浮点数, 持续时间: 整数):
        起始角度 = 旋转角度
        起始时间 = 当前时间()
        
        函数 动画帧():
            当前时间 = 当前时间()
            经过时间 = 当前时间 - 起始时间
            进度 = 最小值(经过时间 / 持续时间, 1)
            
            // 缓动函数
            缓动进度 = 1 - (1 - 进度) ^ 3
            
            旋转角度 = 起始角度 + (目标角度 - 起始角度) * 缓动进度
            
            // 重绘转盘
            绘制转盘(...)
            
            如果 进度 < 1:
                请求动画帧(动画帧)
            否则:
                // 旋转完成
                是否旋转中 = false
                显示结果()
        
        请求动画帧(动画帧)
    
    方法 显示结果():
        游戏引擎.完成抽奖(选中模块)
        
        显示消息("获得了: " + 选中模块.名称)
```

这是UI渲染和交互逻辑的完整伪代码。现在让我整理一份完整的总结文档。
