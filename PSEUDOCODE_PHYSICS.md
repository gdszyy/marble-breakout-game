# 弹珠编程打砖块游戏 - 物理系统和碰撞检测伪代码

## 1. 物理工具函数

```
函数 计算距离(点1: Vector2, 点2: Vector2) -> 浮点数:
    dx = 点2.x - 点1.x
    dy = 点2.y - 点1.y
    返回 平方根(dx * dx + dy * dy)

函数 归一化(向量: Vector2) -> Vector2:
    长度 = 平方根(向量.x * 向量.x + 向量.y * 向量.y)
    如果 长度 == 0:
        返回 {x: 0, y: 0}
    返回 {x: 向量.x / 长度, y: 向量.y / 长度}

函数 向量点积(向量1: Vector2, 向量2: Vector2) -> 浮点数:
    返回 向量1.x * 向量2.x + 向量1.y * 向量2.y

函数 向量反射(入射向量: Vector2, 法线: Vector2) -> Vector2:
    // 反射公式: R = V - 2 * (V · N) * N
    点积 = 向量点积(入射向量, 法线)
    返回 {
        x: 入射向量.x - 2 * 点积 * 法线.x,
        y: 入射向量.y - 2 * 点积 * 法线.y
    }

函数 旋转向量(向量: Vector2, 角度: 浮点数) -> Vector2:
    // 角度转弧度
    弧度 = 角度 * PI / 180
    cos值 = 余弦(弧度)
    sin值 = 正弦(弧度)
    
    返回 {
        x: 向量.x * cos值 - 向量.y * sin值,
        y: 向量.x * sin值 + 向量.y * cos值
    }

函数 矩形包含点(矩形: {x, y, 宽度, 高度}, 点: Vector2) -> 布尔值:
    返回 点.x >= 矩形.x 且
         点.x <= 矩形.x + 矩形.宽度 且
         点.y >= 矩形.y 且
         点.y <= 矩形.y + 矩形.高度

函数 圆形与矩形碰撞(圆心: Vector2, 半径: 浮点数, 矩形: {x, y, 宽度, 高度}) -> 布尔值:
    // 找到矩形上最近的点
    最近点X = 最大值(矩形.x, 最小值(圆心.x, 矩形.x + 矩形.宽度))
    最近点Y = 最大值(矩形.y, 最小值(圆心.y, 矩形.y + 矩形.高度))
    
    // 计算距离
    距离 = 计算距离(圆心, {x: 最近点X, y: 最近点Y})
    
    返回 距离 < 半径

函数 圆形与圆形碰撞(圆心1: Vector2, 半径1: 浮点数, 圆心2: Vector2, 半径2: 浮点数) -> 布尔值:
    距离 = 计算距离(圆心1, 圆心2)
    返回 距离 < 半径1 + 半径2
```

## 2. 子弹物理系统

```
类 BulletPhysics:
    常量 子弹速度 = 400  // 像素/秒
    常量 穿透子弹伤害CD = 100  // 毫秒
    常量 边界反弹衰减 = 0.9
    
    方法 更新子弹(子弹: Bullet, 时间差: 浮点数, 画布宽度: 整数, 画布高度: 整数):
        // 更新位置
        子弹.位置.x += 子弹.速度.x * 时间差 / 1000
        子弹.位置.y += 子弹.速度.y * 时间差 / 1000
        
        // 边界碰撞检测
        碰到边界 = false
        
        // 左右边界
        如果 子弹.位置.x - 子弹.半径 < 0:
            子弹.位置.x = 子弹.半径
            子弹.速度.x = -子弹.速度.x * 边界反弹衰减
            碰到边界 = true
        如果 子弹.位置.x + 子弹.半径 > 画布宽度:
            子弹.位置.x = 画布宽度 - 子弹.半径
            子弹.速度.x = -子弹.速度.x * 边界反弹衰减
            碰到边界 = true
        
        // 顶部边界
        如果 子弹.位置.y - 子弹.半径 < 0:
            子弹.位置.y = 子弹.半径
            子弹.速度.y = -子弹.速度.y * 边界反弹衰减
            碰到边界 = true
        
        // 底部边界（子弹消失）
        如果 子弹.位置.y > 画布高度:
            返回 false  // 标记为需要移除
        
        返回 true  // 子弹继续存在
    
    方法 处理子弹砖块碰撞(子弹: Bullet, 砖块: Brick, 当前时间: 时间戳) -> {碰撞: 布尔值, 砖块被摧毁: 布尔值}:
        // 获取子弹类型
        解析结果 = BulletProgramProcessor.解析编程(子弹.编程序列)
        
        根据 解析结果.基础子弹类型:
            当 NORMAL:
                返回 处理普通子弹碰撞(子弹, 砖块)
            当 PIERCING:
                返回 处理穿透子弹碰撞(子弹, 砖块, 当前时间)
            当 AOE:
                返回 处理AOE子弹碰撞(子弹, 砖块)
        
        返回 {碰撞: false, 砖块被摧毁: false}
    
    方法 处理普通子弹碰撞(子弹: Bullet, 砖块: Brick) -> {碰撞: 布尔值, 砖块被摧毁: 布尔值}:
        // 检测碰撞
        如果 not 圆形与矩形碰撞(子弹.位置, 子弹.半径, {
            x: 砖块.位置.x,
            y: 砖块.位置.y,
            宽度: 砖块.尺寸.宽度,
            高度: 砖块.尺寸.高度
        }):
            返回 {碰撞: false, 砖块被摧毁: false}
        
        // 造成伤害
        砖块.生命值 -= 子弹.伤害
        
        // 计算反弹方向
        砖块中心 = {
            x: 砖块.位置.x + 砖块.尺寸.宽度 / 2,
            y: 砖块.位置.y + 砖块.尺寸.高度 / 2
        }
        
        碰撞法线 = 归一化({
            x: 子弹.位置.x - 砖块中心.x,
            y: 子弹.位置.y - 砖块中心.y
        })
        
        // 反弹
        如果 子弹.剩余反弹次数 > 0:
            子弹.速度 = 向量反射(子弹.速度, 碰撞法线)
            子弹.剩余反弹次数 -= 1
            返回 {碰撞: true, 砖块被摧毁: 砖块.生命值 <= 0}
        否则:
            // 没有反弹次数，子弹消失
            返回 {碰撞: true, 砖块被摧毁: 砖块.生命值 <= 0}
    
    方法 处理穿透子弹碰撞(子弹: Bullet, 砖块: Brick, 当前时间: 时间戳) -> {碰撞: 布尔值, 砖块被摧毁: 布尔值}:
        // 检测碰撞
        如果 not 圆形与矩形碰撞(子弹.位置, 子弹.半径, {
            x: 砖块.位置.x,
            y: 砖块.位置.y,
            宽度: 砖块.尺寸.宽度,
            高度: 砖块.尺寸.高度
        }):
            返回 {碰撞: false, 砖块被摧毁: false}
        
        // 检查伤害CD
        如果 子弹.上次伤害时间 且 (当前时间 - 子弹.上次伤害时间) < 穿透子弹伤害CD:
            返回 {碰撞: false, 砖块被摧毁: false}
        
        // 造成伤害
        砖块.生命值 -= 子弹.伤害
        子弹.上次伤害时间 = 当前时间
        
        // 穿透子弹不消失，继续飞行
        返回 {碰撞: true, 砖块被摧毁: 砖块.生命值 <= 0}
    
    方法 处理AOE子弹碰撞(子弹: Bullet, 砖块: Brick) -> {碰撞: 布尔值, 砖块被摧毁: 布尔值, 创建AOE: 布尔值}:
        // 检测碰撞
        如果 not 圆形与矩形碰撞(子弹.位置, 子弹.半径, {
            x: 砖块.位置.x,
            y: 砖块.位置.y,
            宽度: 砖块.尺寸.宽度,
            高度: 砖块.尺寸.高度
        }):
            返回 {碰撞: false, 砖块被摧毁: false, 创建AOE: false}
        
        // 造成伤害
        砖块.生命值 -= 子弹.伤害
        
        // 创建AOE圆环
        返回 {
            碰撞: true, 
            砖块被摧毁: 砖块.生命值 <= 0,
            创建AOE: true
        }
```

## 3. AOE圆环系统

```
类 AOERingPhysics:
    常量 最大半径 = 100  // 像素
    常量 扩展速度 = 200  // 像素/秒
    常量 伤害 = 5
    
    方法 创建AOE圆环(中心: Vector2) -> AOERing:
        返回 {
            ID: 生成唯一ID(),
            位置: 中心,
            当前半径: 0,
            最大半径: 最大半径,
            扩展速度: 扩展速度,
            伤害: 伤害,
            已伤害砖块集合: 新建Set()
        }
    
    方法 更新AOE圆环(圆环: AOERing, 时间差: 浮点数) -> 布尔值:
        // 扩展半径
        圆环.当前半径 += 圆环.扩展速度 * 时间差 / 1000
        
        // 检查是否达到最大半径
        如果 圆环.当前半径 >= 圆环.最大半径:
            返回 false  // 标记为需要移除
        
        返回 true  // 继续存在
    
    方法 检测AOE伤害(圆环: AOERing, 砖块: Brick) -> 布尔值:
        // 检查是否已经伤害过
        如果 砖块.ID 在 圆环.已伤害砖块集合 中:
            返回 false
        
        // 计算砖块中心
        砖块中心 = {
            x: 砖块.位置.x + 砖块.尺寸.宽度 / 2,
            y: 砖块.位置.y + 砖块.尺寸.高度 / 2
        }
        
        // 检测是否在圆环范围内
        距离 = 计算距离(圆环.位置, 砖块中心)
        
        如果 距离 <= 圆环.当前半径:
            // 造成伤害
            砖块.生命值 -= 圆环.伤害
            圆环.已伤害砖块集合.添加(砖块.ID)
            返回 true
        
        返回 false
```

## 4. 轨迹预测系统

```
类 TrajectoryPredictor:
    常量 预测步数 = 100
    常量 每步时间 = 0.016  // 约60fps
    
    方法 预测轨迹(起点: Vector2, 方向: Vector2, 速度: 浮点数, 画布宽度: 整数, 画布高度: 整数) -> Array<Vector2>:
        轨迹点列表 = [起点]
        
        当前位置 = 复制(起点)
        当前速度 = {
            x: 方向.x * 速度,
            y: 方向.y * 速度
        }
        
        对于 i 从 0 到 预测步数 - 1:
            // 更新位置
            当前位置.x += 当前速度.x * 每步时间
            当前位置.y += 当前速度.y * 每步时间
            
            // 检测边界碰撞
            如果 当前位置.x < 0:
                当前位置.x = -当前位置.x
                当前速度.x = -当前速度.x
            如果 当前位置.x > 画布宽度:
                当前位置.x = 2 * 画布宽度 - 当前位置.x
                当前速度.x = -当前速度.x
            如果 当前位置.y < 0:
                当前位置.y = -当前位置.y
                当前速度.y = -当前速度.y
            如果 当前位置.y > 画布高度:
                // 触底，停止预测
                跳出循环
            
            轨迹点列表.添加(复制(当前位置))
        
        返回 轨迹点列表
    
    方法 计算瞄准方向(起点: Vector2, 目标点: Vector2) -> Vector2:
        方向向量 = {
            x: 目标点.x - 起点.x,
            y: 目标点.y - 起点.y
        }
        
        返回 归一化(方向向量)
```

## 5. 碰撞检测管理器

```
类 CollisionManager:
    方法 检测所有子弹砖块碰撞(状态: GameState, 当前时间: 时间戳):
        需要移除的子弹ID列表 = []
        需要移除的砖块ID列表 = []
        新AOE圆环列表 = []
        
        对于 状态.子弹列表 中的每个 子弹:
            子弹碰撞了 = false
            
            对于 状态.砖块列表 中的每个 砖块:
                碰撞结果 = BulletPhysics.处理子弹砖块碰撞(子弹, 砖块, 当前时间)
                
                如果 碰撞结果.碰撞:
                    子弹碰撞了 = true
                    
                    如果 碰撞结果.砖块被摧毁:
                        需要移除的砖块ID列表.添加(砖块.ID)
                        状态.分数 += 10
                    
                    如果 碰撞结果.创建AOE:
                        AOE圆环 = AOERingPhysics.创建AOE圆环(子弹.位置)
                        新AOE圆环列表.添加(AOE圆环)
                        需要移除的子弹ID列表.添加(子弹.ID)
                        跳出内层循环
                    
                    // 普通子弹碰撞后消失
                    解析结果 = BulletProgramProcessor.解析编程(子弹.编程序列)
                    如果 解析结果.基础子弹类型 == NORMAL 且 子弹.剩余反弹次数 <= 0:
                        需要移除的子弹ID列表.添加(子弹.ID)
                        跳出内层循环
        
        // 移除被摧毁的砖块
        状态.砖块列表 = 状态.砖块列表.过滤(砖块 => 砖块.ID 不在 需要移除的砖块ID列表 中)
        
        // 移除消失的子弹
        状态.子弹列表 = 状态.子弹列表.过滤(子弹 => 子弹.ID 不在 需要移除的子弹ID列表 中)
        
        // 添加新AOE圆环
        状态.AOE圆环列表.添加所有(新AOE圆环列表)
    
    方法 检测所有AOE伤害(状态: GameState):
        需要移除的砖块ID列表 = []
        
        对于 状态.AOE圆环列表 中的每个 圆环:
            对于 状态.砖块列表 中的每个 砖块:
                如果 AOERingPhysics.检测AOE伤害(圆环, 砖块):
                    如果 砖块.生命值 <= 0:
                        需要移除的砖块ID列表.添加(砖块.ID)
                        状态.分数 += 10
        
        // 移除被摧毁的砖块
        状态.砖块列表 = 状态.砖块列表.过滤(砖块 => 砖块.ID 不在 需要移除的砖块ID列表 中)
```

## 6. 物理常量配置

```
配置 PhysicsConfig:
    // 弹珠物理
    弹珠重力 = 500  // 像素/秒²
    弹珠初始速度X范围 = [-50, 50]  // 像素/秒
    弹珠反弹衰减 = 0.85  // 每次碰撞后速度衰减
    弹珠半径 = 8  // 像素
    
    // 子弹物理
    子弹速度 = 400  // 像素/秒
    子弹半径 = 8  // 像素
    子弹伤害 = 10
    
    // 缓冲器
    缓冲器半径 = 20  // 像素
    缓冲器基础冷却 = 500  // 毫秒
    
    // AOE
    AOE最大半径 = 100  // 像素
    AOE扩展速度 = 200  // 像素/秒
    AOE伤害 = 5
    
    // 穿透子弹
    穿透伤害CD = 100  // 毫秒
    
    // 边界
    边界反弹衰减 = 0.9
```

这是物理系统和碰撞检测的完整伪代码。接下来我会继续记录UI渲染和交互逻辑。
